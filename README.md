====== VNC-клиент ======

Разработчик: Меркушов Д.А. (тел. +7-916-809-76-10)

Исходные тексты доступны в GitLab: http://10.1.2.97/gitlab/9f753/vnc-client

Исходные тексты ориентированы на компиляцию в Java 8. При необходимости, после незначительных доработок могут быть также скомпилированы в Java 6 или 7.

Пример команды для клонирования исходных текстов:

  git clone gitlab@10.1.2.97:9f753/vnc-client.git

Текущая условно-стабильная разрабатываемая версия содержится в ветви develop. Текущая стабильная версия содержится в ветви master. Текущие версии по разрабатываемым возможностям содержатся в соответствующих ветвях.

Собранная версия 1.0 доступна в Maven-репозитории Nexus: http://194.85.135.10:8081/nexus/service/local/repositories/releases/content/ru/dmerkushov/vnc-client/1.0/vnc-client-1.0.jar

===== Общие сведения =====

==== Протокол VNC ====

VNC описан в RFC 6143. VNC-коммуникация базируется на протоколе RFB (Remote FrameBuffer). Более расширенная версия RFB, чем описана в RFC 6143, предлагается в нестандартизированной спецификации rfbproto, доступной на GitHub в репозитории rfbproto/rfbproto.

Копии RFC 6143 и rfbproto по состоянию на 14 декабря 2016 года имеются в Git-репозитории разработанного VNC-клиента.

Сессия обычно проходит три основные стадии:

  * Установление соединения (handshake)
  * Инициализация (initialization)
  * Нормальное функционирование (normal)

На стадии установления соединения клиент подключается к серверу по TCP. Они согласуют версию RFB, которую следует использовать (protocol version handshake), затем сервер проверяет подлинность клиента (security handshake).

На стадии инициализации клиент отправляет информацию о том, стоит ли разделять сессию между несколькими клиентами (этим и подключившимися ранее). Сервер отправляет информацию о предпочитаемом формате представления пикселей и внутреннем названии сессии.

На стадии нормального функционирования клиент запрашивает обновления фреймбуфера (framebuffer update request), сообщает о событиях указателя (pointer events) и клавиатуры (key events). Сервер сообщает об обновлениях фреймбуфера (framebuffer update). Также возможны другие (вспомогательные) сообщения:

  * Со стороны клиента:
    * Установка формата пикселя (set pixel format)
    * Установка допустимых представлений фреймбуфера и предоставление информации о поддерживаемых клиентом расширениях (set encodings)
    * Текст в буфере обмена (client cut text)
  * Со стороны сервера:
    * Звуковой сигнал (bell)
    * Установка палитры (set colormap entries)
    * Текст в буфере обмена (server cut text)

=== Допустимые представления графических данных фреймбуфера ===

В соответствии с RFC 6143, допускаются следующие представления (encodings) графической информации, содержащейся во фреймбуфере (точнее, в передаваемом прямоугольнике, входящем во фреймбуфер):

  * Raw - прямое представление (прямоугольник пикселей)
  * CopyRect - копирование ранее переданного прямоугольного участка в другой
  * RRE - через набор прямоугольников одинакового цвета произвольных размеров
  * Hextile - через вариативное кодирование прямоугольников (тайлов) размером 16x16 пикселей
  * TRLE - более продвинутое, чем Hextile, вариативное кодирование тайлов
  * ZRLE - TRLE-информация, сжатая с помощью Zlib

В rfbproto также описаны следующие представления:

  * CoRRE
  * zlib
  * Tight
  * zlibhex

Следует иметь в виду, что представлений имеется большое множество. Например, в запросах о развитии клиента TigerVNC попадалась просьба о поддержке представления, используемого VNC-сервером vino.

==== Причины разработки ====

Существует реализация VNC-клиента (VNC viewer) на языке Java, входящая в поставку VNC-комплекта TigerVNC, поставляемого с исходными кодами. По сравнению с нашим VNC-клиентом, она обладает следующими преимуществами:

  * Поддерживает расширения TigerVNC, сделанные к протоколу VNC. В частности, представление фреймбуфера Tight, разработанное в рамках проекта TightVNC, широко используется сервером TigerVNC, унаследованным от TightVNC.

В то же время, ей свойственны следующие недостатки:

  * Ориентация на использование в качестве отдельного приложения, без возможности встраивания компонента, отвечающего за отображение удалённого экрана, в произвольное собственное приложение на Java
  * Ориентация на единственное VNC-соединение в пределах одной JVM
  * Неиспользование возможностей, появившихся после версии Java 1.1, например, расширенный потоковый ввод-вывод, общие (generic) типы и пр.

Эти недостатки не позволяют использовать этот программный продукт в составе тренажёра 9Ф753, где, в частности, требуется встроить __несколько__ просмотрщиков в наше ПО. Других VNC-клиентов, не имеющих перечисленных недостатков, найдено не было (существуют более старые VNC-клиенты, от которых последовательно унаследован TigerVNC: RealVNC и TightVNC).

===== Информация о разработке =====

==== Структура исходных текстов ====

Java-пакеты исходных текстов:

  * ru.dmerkushov.vnc.client - основной пакет, содержит классы Main (пример использования VNC-клиента), VncCommon (общие данные для VNC-клиента), VncException (базовый класс для исключений)
    * rfb - классы, реализующие протокол RFB
      * data - основные данные: RfbColorMap (палитра), RfbPixelFormat (формат пикселя), RfbRectangle (прямоугольник фреймбуфера)
        * pixeldata - представления графических данных
      * messages - сообщения RFB, с разбиением по стадиям: handshake, initialization, normal
      * operation - реализации стадий работы RFB
      * session - реализация RFB-сессии с клиентской стороны (класс RfbClientSession) и вспомогательные классы к нему
        * password - интерфейс PasswordSupplier (получение пароля VNC) и его реализация по умолчанию UiPasswordSupplier (получение пароля путём запроса к пользователю с помощью диалогового окна)
    * ui  - классы, реализующие GUI: VncView (Swing-компонент просмотра VNC) и ThumbnailView (универсальный Swing-компонент предпросмотра в произвольном размере)
      * events - классы, реализующие события для отправки на VNC-сервер